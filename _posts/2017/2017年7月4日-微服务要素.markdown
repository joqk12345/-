## 微服务要素
1. 如今,软件通常会作为一种服务来交付,他们被成为网络应用程序,或软件及服务.
2. 12要素应用程序(12-Factor-App)为构建如下的Saas应用提供了方法:
    1. 使用标准化流程自动配置,从而使新的开发者花费最少的学习成本加入这个项目
    2. 和操作系统之间尽可能的划清界限,在各个系统中提供最大的可移植性;
    3. 适合部署在现代的云计算平台,从而在服务器和系统管理方面节省资源;
    4. 将开发环境和生产环境的差异降低到最低,并试用持续交付实施敏捷开发;
    5. 可以在工具,架构和开发流程不发生明显G币安华的前提下实现扩展;
3. 这套理论适用于任意语言和后端服务(数据库/消息队列/缓存等)开发的应用程序

## 十二要素
1. 基准代码
    1. 一份基准代码,多份部署
    2. 基准代码和应用之间总是保持--对应的关系
    3. 一代有多个基准代码,就不能成为一个应用,而是一个分布式系统.分布式系统中的每个组件都是一个应用,每一个应用可以分别使用12-factor进行开发.
    4. 多个应用共享一份基准代码是有悖于12-Factor原则的.解决方案是将共享代码拆分为独立的类库,然后使用以来管理策略去加载他们.尽管每个应用只对应一份基准代码,但可以同时存在多份部署.所有部署的基准代码相同,但每份部署可以使用不同的版本.
2. 依赖
    显式声明依赖关系
    12-Factor规则下应用程序不会隐式依赖系统级类库.他一定通过依赖清单,确切声明所有依赖项.此外在使用中使用以来隔离工具来确保程序不会调用系统中存在但清单中未声明的依赖项.这一做法会统一应用到生产和开发环境中.
3. 配置
    在环境中存储配置
    12-Factor推荐将应用的配置存储于环境变量(env/vars/env).环境变量可以非常方便地在不同的部署间做修改,却不动一行代码;
    与配置文件不同,不小心把他们嵌入代码库的概率微乎其微,与这些传统的解决配置文件的机制,比如(java中的属性配置文件)相比,环境变量与语言无关
    12-factor应用中,环境变量之间的粒度要足够的小,且相对独立,他们永远也不会组合成为一个所谓的"环境",而是独立存在于每个部署之中,当应用程序不断扩展,需要更多中类的部署时,这种配置方式能够做到平滑过渡.
4. 后端服务
    把后端服务当做附加资源
    12-Factor应用不会区别对待本地或第三方服务.对应用程序而言,两种都是附加资源,通过一个url或是其他存储在配置中的服务定位/服务证书来获取数据.12-Factor应用的任意部署,都应该可以在不进行任何代码改动的情况下,将本地Mysql数据库换成第三方服务(例如:Amazon RDS)
5. 构建/发布/运行
    严格分离构建与运行
6. 进程
    一个或多个无状态进程运行应用.
    任何需要持久化的数据都要存储在后端服务内,比如数据库.粘性Session是12-factor极力反对的.Seesion中的数据应保存在诸如Memcached或Redis这样的带有过期时间的缓存中.
7. 端口绑定
    通过端口绑定提供服务.
8. 并发
    通过进程模型进行扩展.
    在12-Factor应用中,进程是一等公民.12-Factor应用进程主要借鉴于unix守护进程模型.开发人员可以运用这个模型去设计应用架构,将不同的工作分配给不同的类型.
9. 易处理
    快速启动和优雅终止可最大化健壮性.
    12-Factor应用的进程是可支配的,意思是说他可以瞬间开启或停止.这有利于快速/弹性的伸缩应用,迅速部署变化的代码或配置,稳健地部署应用.进程应当追求最小启动时间;
    进程一旦接受终止信号(SIGTERM)就会比较优雅的终止.进程还应当面对突然死亡的时候保持健壮. 
10. 开发环境与线上环境等价
    尽可能保持开发/预发布/线上环境相同
11. 日志
    把日志当做事件流
12. 管理进程
    后台管理任务当做一次性进程运行
    一次管理进程应该和正常常驻进程使用同样的环境.这些管理进程和任何其他的进程使用相同的代码和配置,基于某个发布版本运行.后台管理代码应该随其他应用程序代码一起发布,从而避免同步问题.所有进程类型应该使用童颜的依赖隔离技术.
    12-Factor尤其青睐那些提供了REPL shell的语言,因为那会让运行一次性脚本变得简单.
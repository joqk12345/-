
## SQL数据库
1. 连接相关
    1. Inner join 内连接产生的结果是AB的交集
    2. Left [Outer] join 产生表A的全集,而B表中匹配的则有值,则以null值取代
    3. right [Outer] join 产品的b的全集,而a表中没有的值则也null值取代
    4. Full  [Outer] join 产生的是A与b的并集,对于没有匹配的记录,则会以null作为值
    5. select top 子句用于规定要返回的记录的数目
    6. select union操作符用于合并两个或者多个SELECT 语句的结果集( UNION内部的Select 语句必须拥有相同数量的列,列也必须拥有相似的数据类型,每条Select语句中的列的顺序必须相同)
    7. Select
2. 索引(应该建立的字段)
    1. 作为经常需要查询条件的字段
    2. 外键
    3. 经常需要排序的字段
    4. 分组排序的字段


3. mysql中的b-tree索引
    1. b-tree的b是balance
    2. 作用显著减少定位记录所经历的中间过程.
    3. b+tree是B-tree索引的一个变种,大名鼎鼎的MySQL就普遍使用B-tree实现其索引

4. mysql中的hash索引
    1. hash索引其检索效率非常高,索引的检索可以一次定位,所以hash索引的检索效率远高于B-tree索引
    2. Hash索引仅仅满足"=","IN"和"<=>"查询,不能使用范围查询,由于hash索引比较的是进行hash之后的Hash值,所以他只能用于等值的过滤,不能用于基于范围的过滤,因为经过相应的Hash算法处理之后的Hash值的大小关系,并不能保证和Hash运算前完全一样.
    3. hash 索引无法被用来避免数据的排序操作
    4. Hash索引不能利用部分索引键查询(由于has计算的时是利用组合索引一起计算Hash值)
    5. Hash索引在任何时候都不能避免扫描表
        1. 计算原理是将hash键通过hash运算完毕之后将运算结果的Hash值和所对应的行指针信息存放于一个Hash表中,由于不同索引键存在相同的Hash值,所以即使取满足某个Hash键值的数据的记录条数,也无法从hash索引中直接完成查询,还是要通过访问表中的实际数据进行相应的比较,并的到相应的结果
    6. Hash 索引遇到大量Hash值相等的情况后性能并不一定会比B-tree索引性能高
        1. 对于选择性比较低的索引键,如果创建Hash索引,那么将会存在大量记录指针信息存储同一个Hash值相关联,这样要定某一条记录就会非常麻烦,会浪费多次表数据的访问,而造成整体性能的地下

5. mysql的存储引擎介绍与说明
    1. mysan
    2. innodb

6. sql的注入
    1. 把sql命令插入到Web表单提交或者输入域名活页面请求的查询字符串,最终达到欺骗服务器执行恶意SQL的命令
    2. 防止办法
        1. 永远不要信任任何用户的输入
        2. 永远不要使用动态拼装的SQL.
        3. 永远不要使用管理员权限的数据库连接
        4. 不要吧机密信息直接存放,加密或者hash掉密码和敏感信息
        5. 应用的异常信息应该给出尽可能少的提示,最好使用自定义的错误信息对原始错误数据进行包赚
        6. 采用辅助软件或者平台来检测
7. mysql中的锁
8. 事务


##　缓存(cache)
1. cache如何实现
2. redis
    1. 数据结构
    2. 持久
    3. 复制
    4. cas
    5. 单线程
3. Memcache
4. Tair

## 消息队列
1. JMS  
    1. Queue
    2. Topic
2. kafka
    1. 持久
    2. 复制
    3. Partition
    4. Stream
3. RocketMQ
4. RabbitMQ
5. ActiveMQ

## 数据结构相关
1. hash表
    1. hash表也成散列表,也有直接译做哈希表,他同数组链表以及二叉排序树相比较有明显的区别,
    2. 他能够快速定位到想要查找到的记录,而不是与表中存在的记录的关键字进行比较来查找.
    3. 这源于,他采用了函数映射的思想将记录的储存位置与记录的关键字关联起来了,从而能够快速的进行查找
    4. 时间复杂度变为O(1)
    5. 通过key直接过去到该记录在表中的存储位置,能够省掉中间关键词比较的这个中间环节
2. 原理
    1. 映射函数成为hash函数f: key --> address ,将关键字映射到该记录在表中的存储位置,从而在想要查找到该记录时,可以直接根据关键字和映射关系计算出该记录在表中的存储位置.通常这个映射关系成作为Hash函数.
    2. Hash函数的设计好坏直接影响到了Hash表的操作效率
        1. 考虑关键字的分布特点来设计函数,使的Hash地址均匀分布在整个地址空间当中.
            1. 直接定址法
            2. 平方取中法
            3. 折叠法
            4. 除留取余法
        2. 冲突的解决
            1. 开放地址法
            2. 链地址法
        3. Hash表大小的确定
            1. 根据最终记录存储个数和关键词分布的特点来确定hash表的大小
            2. 动态维护Hash表的容量,溶蚀需要重新计算Hash地址
        4. hash表的平均查找长度
            1. 查找成功的平均查找长度=表中每个元素查成功时的比较次数之和/表中的元素数
            2. 
        5. Hash表优缺点
            1. 有点显而易见,能够在常数级的时间复杂度上进行查找,并且插入数据和删除数据都比较容易.
            2. 缺点:比如不支持排序,一样比用线性表要存储更多的空间,并且记录的关键子不能重复.
2. hashMap和hashTable的区别
    1. HashMap和HashTable都实现了Map接口,但决定用哪个之前先要弄清楚他们之间的分别.
    2. HashMap几乎可以等价于HashTable,除了HashMap是非cynchronized,并可以接受null,
    3. HashTable是线程安全的,,是synchronized,多个线程可以共享HashTable;如果没有正常同步的话多线线程是不能共享HashMap的.
    4. HashMap的迭代器(Iterator)是fail-fast迭代器
    5. 单线程环境下HashTable要比HashMap要慢
    6. HashMap不能保证随着时间的推移Map中的元素次序是不变的.
3. 重要术语
    1. sychronized意味着在一次仅有一个线程能够更改HashTable.就是说任何线程要修改更新Hashtable时要活得同步锁,其他线程要等同步锁释放之后才能在次更新HashTable
    2. 结构上的更改是只删除或者插入一个元素,这样会影响map的结构
    3. Fail-safe和iterator迭代器相关.如果某个集合对象创建了Iterator或者ListIterator,然后其他的线程试图"结构上"更改集合对象,将会抛出"ConcurrentModificationException".但是其他线程可以通过set()方法更改集合对象是允许的,因为这并没有从结构上更改集合对象.
4. 能够让HashMap同步
    1. HashMap可以通过下面的术语同步:
        1. Map m = Collection.synchronizeMap(hashMap);
5. Haashtable和HashMap有一个主要的不同:
    1. 线程安全以及速度.
    2. 仅在需要线程安全的时候使用hashTable,
    3. 在高版本上的话请使用ConcurrentHashMap

## 算法相关

## java中堆内存和栈内存详解
1. 栈内存  
    1. 一些基本类型的变量和对象的引用变量都是在含住的栈内存中分配
    2. 堆内存用于存放由new创建的对象和数组
2. java 中的内存分配策略
    1. 静态分配-编译时期就能确定每个数据目标在运行时刻存储空间的需求
    2. 栈式存储分配--动态存储分配
3. 搜索
    1. 二分搜索
4. 排序
    1. 选择
    2. 冒泡排序
    3. 插入排序
    4. 快速排序
    5. 归并排序
    6. 堆排序
    7. 桶排序
    8. 基数排序
5. 高级算法
    1. 贪婪算法
    2. 回溯算法
    3. 剪枝算法
    4. 动态规划
6. 大数据算法
    1. hash分桶
    2. 统计

## 分布式
1. 负载均衡
    1. nginx
    2. fegin(spring-cloud)
    3. XX
    4. 当然还有基于硬件的负载均衡
2. 水平伸缩
3. 集群
4. 分片
    1. key-hash
    2. 一致性hash
5. 异步
6. 消峰
7. 分库分表
8. 锁
    1. 悲观锁
    2. 乐观锁
    3. 行级锁
    4. 分布式锁
    5. 分区排队
9. 分布式事务(HAWQ)
## 反射
1. 对于一个任意的类都能知道其所有属性和方法
2. 对于一个任意的对象都能够通过反射机制来调用一个类的任意方法.
3. 这种动态获取类信息及动态调用类对象的方法的功能称为java的反射机制.
4. 反射的作用
    1. 动态的创建类的实例,将类绑定到现有的对象中,或从现有的对象中获取类型
    2. 应用程序需要在运行时从某个特定的程序集中载入一个车特定的类
## 多媒体相关
1. bit-map
2. 语音
    1. 数据采集--数据预处理-数据标注(标注系统)--数据训练--数据上线等
3. 视频
    1. ffmpeg
    2. openCV

##  MongoDB

## HBase 
1. flash数据结构




##　java语言
1. 异常
2. 类继承
3. 泛型
4. 内部类
5. 反射
6. 序列化
7. 对象类
8. 字符串类
9. 引用
    1. 弱引用
    2. 强引用
    3. 软引用
    4. 幻影引用
10. 类库
    1. 集合
    2. 流

##　linux相关

## 云计算
1. IAAS Openstack
2. 虚拟化
3. 容器技术
    1. docker
    2. k8s
## 分布式存储相关
1. NFS/阵列存储集中式存储
2. 龙存
3. ceph的分部式存储

## 脚本语言python/shell
1. puppet
2. chef自动化运维
3. zebix

## 深度神经网络相关
1. tensor flow
2. dnn4j
3. GPU与并行计算

## 多线程与并发
1. ![线程状态](http://img.blog.csdn.net/20170304134110520?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2luYXRfMzU1MTIyNDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
2. 线程状态
    1. 新建:新建一个线程对象
    2. 可运行:从锁池里难道锁标识
    3. 运行:OS选中执行
    4. 阻塞:等待用户输入
        1. 线程因为某种原因放弃了cpu使用权,也让出了cpu timelice ,暂时停止运行.直到线程进入可运行(runnable)状态,才有机会再次获得cpu timeslice转到(running)状态.
        2. 分类
            1. 等待阻塞:运行的线程执行o.wait()方法,JVM会把该线程放入等待队列(waitting queue)中
            2. 同步阻塞:运行的线程在获取对象的同步锁时,若该同步锁被别的线程占用,JVM则会把改现车给你放入锁池中(lock pool)中.
            3. 其他阻塞:运行的线程执行Thread.sleep(long ms)或t.join()方法,或者发出了I/O请求时,JVM会把改线程置为阻塞状态.当sleep()状态超时/join()等待线程终止是hi欧,或者I/o处理完毕的时候,线程重新转入可以运行(runnable)状态.   
    5. 死亡:run()/main()方法结束/或者异常退出

2. 线程间通信模型
    1. 线程间的相互作用:线程之间需要一些协调通信,来共同完成一件任务.
    2. wait()方法:使得当前线程必须要等待,等到另外一个线程调用notify()或者notifyAll()
        1. 线程释放他对锁的拥有权,然后等待另外的线程来通知它,这样他才能重新获得所的拥有权和恢复执行
        2. wait()方法必须放在synchronized方法或synchronized块中.
        3. 另一个会导致现车给你暂停的方法:Thread.sleep(),他会导致线程睡眠指定的毫秒数,但是现车给你在睡眠过程中不会释放掉对象的锁的.
    3. notify()方法
        1. notify()方法会唤醒一个等待当前对象锁的线程.
            1. 如果多个线程在等待,他们中的一个将会选择被唤醒.这种选择是随意的,和具体实现有关.
            2. 被唤醒的线程是不能被执行的,需要等到当前线程放弃这个对象的锁.
            3. 被唤醒的线程将和其他线程以通常的方式进行竞争,来获得对象的锁.
##　java内存模型的理解以及其在并发当中的作用
1. Java平台自动集成了线程阿姨级多处理器技术,这种机车姑奶程度比java以前诞生的计算机语言要厉害的多.改语言针对多种易购屁股虐爱的平台独立性而使得多线程技术知己也是具有开拓性的一面.
2. java内存模型,内存模型描述了程序中各个变量(实例域/静态域和数组元素)之间的关系,以及在实际计算机系统中将变量存储到内存和从内存中取出变量的这样的细节.对象最终是要存储在内存里面的,这点没有错,但是编译器/运行库/处理器或者系统缓存可以有特权在变量指定内存内存位置存储或者取出变量的值
3. JMM:java内存模型允许编译器和缓存一数据在处理器特定的缓存(或寄存器)和主存之间移动的次序有重要的特权,除非程序员使用了final或者synchronized明确请求了某些可见性的保证.
4. 在java 中应为不同的目的可以将java划分为两种内存模型
    1. GC内存模型
    2. 并发内存模型
5. GC内存模型
    1. java与C++ 之间有一堵内存动态分配与垃圾收集技术所围成的"高墙",墙外面的人想进去,墙里面的人想出来.java在执行java程序的过程中会把他管理的内存划分若干不同功能的数据管理区域.
    2. ![java-gc内存模型](http://images2015.cnblogs.com/blog/286989/201611/286989-20161124093427206-761806286.jpg)
    3. ![java-堆内存模型](http://images2015.cnblogs.com/blog/286989/201701/286989-20170112150556791-818433561.png)
    4. ![分代的堆空间](http://images2015.cnblogs.com/blog/286989/201701/286989-20170112150607822-1924598543.jpg)
6. hotspot中的gc内存模型
    1. 栈/虚拟机/本地方法栈
        1. 在栈中会给每个线程创建一个站.线程越多,栈的内存空间使用越大.
        2. 对于每个线程栈,当一个方法在线程中执行的时候,会在现车给你栈中创建一个栈帧(stack frame),用于存放该方法的上下文局部变量表/操作数栈/方法返回值的地址.每一个方法调用到执行完毕的过程,就是对应一个栈帧入栈到出栈的过程.
        3. 本地方法栈为虚拟机执行native方法服务的,虚拟机栈为虚拟机执行java(字节码)服务的.
    2. 堆/方法区
        1. 方法区就是在堆中称为永久代的堆区域.
        2. 几乎所有的对象/数组的内存空间都在堆上.
        3. 虚拟机对分为
            1. 新生代
                1. 一个eden区
                2. 两个survivor区
                3. 策略:mark-copy
            2. 老年代
                1. 新生代中的对象经过若干轮回gc后还存活/或survisor在gc内存不够的时候.会把当前对象移动到老年代.
                2. 策略:mark-compact
            3. 永久代
                1. 永久代不参与gc.
                2. 代码/常量数据/类信息
                3. 清除的是类信息以及常量池
    3. 程序技术器
        程序计数器用于技术某个线程下执行指令的位置,程序计数器也是线程私有的.
## GC
1. GC收集器类型
    1. 串行
    2. CMS
    3. 并行
    4. G1
2. 算法
    1. 复制
    2. 标记清理
    3. 标记整理
## IO/NIO
    1. 同步阻塞
    2. 同步非阻塞
    3. 基于信号
    4. 多路复用
    5. 异步IO
##　类加载器
1. 双亲委派
2. OSGI

## 性能优化
1. 分层优化
    1. 系统级别
    2. 中间件级别
    3. JVM级别
    4. 代码级别
2. 分段优化
    1. 前端
    2. 后端
    3. 资源

## 测试框架
1. 老框架
    1. junit
    2. easymock
2. 新框架
    1. testing
    2. mockito

## 日志框架
1. 老框架
    1. common logging
    2. log4j,
    3. jdk logger
2. 新框架
    1. slf4j
    2. logback

##　设计模式
1. 门面
2. 代理
3. 工厂
4. 单例


## 网络
1. TCP/IP
2. HTTP


##工作业绩
1. 技术攻关
2. 应急
3. 创新
4. 分享
5. 项目管理
6. 程序开发案例
7. 项目设计案例

## 非技术
1. 责任心
2. 团队精神
3. 主动性
4. 性格
5. 年龄
6. 期待
    1. 做完语音行业应用
    2. 探索更多智能语音交互相关应用
    3. 将语音技术在产品端能有更多的创新
    4. 在语音技术的框架端/应用开发库端更加的好用,能让更多人用,且用起来更简单方便
7. 职业规划
